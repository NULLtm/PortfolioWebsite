{"ast":null,"code":"import * as React from 'react';\nimport { Action, invariant, isRouteErrorResponse, UNSAFE_convertRoutesToDataRoutes, IDLE_NAVIGATION, IDLE_FETCHER } from '@remix-run/router';\nimport { parsePath, Router, UNSAFE_DataStaticRouterContext, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, Routes, UNSAFE_enhanceManualRouteObjects, createPath } from 'react-router-dom';\n\n/**\n * A <Router> that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouter(_ref) {\n  let {\n    basename,\n    children,\n    location: locationProp = \"/\"\n  } = _ref;\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let action = Action.Pop;\n  let location = {\n    pathname: locationProp.pathname || \"/\",\n    search: locationProp.search || \"\",\n    hash: locationProp.hash || \"\",\n    state: locationProp.state || null,\n    key: locationProp.key || \"default\"\n  };\n  let staticNavigator = getStatelessNavigator();\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: location,\n    navigationType: action,\n    navigator: staticNavigator,\n    static: true\n  });\n}\n\n/**\n * A Data Router that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouterProvider(_ref2) {\n  let {\n    context,\n    router,\n    hydrate = true,\n    nonce\n  } = _ref2;\n  !(router && context) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You must provide `router` and `context` to <StaticRouterProvider>\") : invariant(false) : void 0;\n  let dataRouterContext = {\n    router,\n    navigator: getStatelessNavigator(),\n    static: true,\n    basename: context.basename || \"/\"\n  };\n  let hydrateScript = \"\";\n  if (hydrate !== false) {\n    let data = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors)\n    }; // Use JSON.parse here instead of embedding a raw JS object here to speed\n    // up parsing on the client.  Dual-stringify is needed to ensure all quotes\n    // are properly escaped in the resulting string.  See:\n    //   https://v8.dev/blog/cost-of-javascript-2019#json\n\n    let json = JSON.stringify(JSON.stringify(data));\n    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataStaticRouterContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {\n    value: dataRouterContext.router.state\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: dataRouterContext.basename,\n    location: dataRouterContext.router.state.location,\n    navigationType: dataRouterContext.router.state.historyAction,\n    navigator: dataRouterContext.navigator\n  }, /*#__PURE__*/React.createElement(Routes, null))))), hydrateScript ? /*#__PURE__*/React.createElement(\"script\", {\n    suppressHydrationWarning: true,\n    nonce: nonce,\n    dangerouslySetInnerHTML: {\n      __html: hydrateScript\n    }\n  }) : null);\n}\nfunction serializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // deserializeErrors in react-router-dom/index.tsx :)\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = {\n        ...val,\n        __type: \"RouteErrorResponse\"\n      };\n    } else if (val instanceof Error) {\n      // Do not serialize stack traces from SSR for security reasons\n      serialized[key] = {\n        message: val.message,\n        __type: \"Error\"\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction getStatelessNavigator() {\n  return {\n    createHref,\n    encodeLocation,\n    push(to) {\n      throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n    },\n    replace(to) {\n      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere ` + `in your app.`);\n    },\n    go(delta) {\n      throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${delta})\\` somewhere in your app.`);\n    },\n    back() {\n      throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);\n    },\n    forward() {\n      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);\n    }\n  };\n} // Temporary manifest generation - we should optimize this by combining the\n// tree-walks between convertRoutesToDataRoutes, enhanceManualRouteObjects,\n// and generateManifest.\n// Also look into getting rid of `route as AgnosticDataRouteObject` down below?\n\nfunction generateManifest(routes) {\n  let manifest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n  routes.forEach(route => {\n    manifest.set(route.id, route);\n    if (route.children) {\n      generateManifest(route.children, manifest);\n    }\n  });\n  return manifest;\n}\nfunction createStaticRouter(routes, context) {\n  let dataRoutes = UNSAFE_convertRoutesToDataRoutes(UNSAFE_enhanceManualRouteObjects(routes));\n  let manifest = generateManifest(dataRoutes); // Because our context matches may be from a framework-agnostic set of\n  // routes passed to createStaticHandler(), we update them here with our\n  // newly created/enhanced data routes\n\n  let matches = context.matches.map(match => {\n    let route = manifest.get(match.route.id) || match.route;\n    return {\n      ...match,\n      route: route\n    };\n  });\n  let msg = method => `You cannot use router.${method}() on the server because it is a stateless environment`;\n  return {\n    get basename() {\n      return context.basename;\n    },\n    get state() {\n      return {\n        historyAction: Action.Pop,\n        location: context.location,\n        matches,\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: context.errors,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        fetchers: new Map()\n      };\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    initialize() {\n      throw msg(\"initialize\");\n    },\n    subscribe() {\n      throw msg(\"subscribe\");\n    },\n    enableScrollRestoration() {\n      throw msg(\"enableScrollRestoration\");\n    },\n    navigate() {\n      throw msg(\"navigate\");\n    },\n    fetch() {\n      throw msg(\"fetch\");\n    },\n    revalidate() {\n      throw msg(\"revalidate\");\n    },\n    createHref,\n    encodeLocation,\n    getFetcher() {\n      return IDLE_FETCHER;\n    },\n    deleteFetcher() {\n      throw msg(\"deleteFetcher\");\n    },\n    dispose() {\n      throw msg(\"dispose\");\n    },\n    _internalFetchControllers: new Map(),\n    _internalActiveDeferreds: new Map()\n  };\n}\nfunction createHref(to) {\n  return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n  // Locations should already be encoded on the server, so just return as-is\n  let path = typeof to === \"string\" ? parsePath(to) : to;\n  return {\n    pathname: path.pathname || \"\",\n    search: path.search || \"\",\n    hash: path.hash || \"\"\n  };\n}\nexport { StaticRouter, StaticRouterProvider, createStaticRouter };","map":{"version":3,"names":["React","Action","invariant","isRouteErrorResponse","UNSAFE_convertRoutesToDataRoutes","IDLE_NAVIGATION","IDLE_FETCHER","parsePath","Router","UNSAFE_DataStaticRouterContext","UNSAFE_DataRouterContext","UNSAFE_DataRouterStateContext","Routes","UNSAFE_enhanceManualRouteObjects","createPath","StaticRouter","basename","children","location","locationProp","action","Pop","pathname","search","hash","state","key","staticNavigator","getStatelessNavigator","createElement","navigationType","navigator","static","StaticRouterProvider","context","router","hydrate","nonce","process","env","NODE_ENV","dataRouterContext","hydrateScript","data","loaderData","actionData","errors","serializeErrors","json","JSON","stringify","Fragment","Provider","value","historyAction","suppressHydrationWarning","dangerouslySetInnerHTML","__html","entries","Object","serialized","val","__type","Error","message","createHref","encodeLocation","push","to","replace","go","delta","back","forward","generateManifest","routes","manifest","Map","forEach","route","set","id","createStaticRouter","dataRoutes","matches","map","match","get","msg","method","initialized","navigation","restoreScrollPosition","preventScrollReset","revalidation","fetchers","initialize","subscribe","enableScrollRestoration","navigate","fetch","revalidate","getFetcher","deleteFetcher","dispose","_internalFetchControllers","_internalActiveDeferreds","path"],"sources":["C:/Users/nullt/Documents/GitHub/portfoliowebsite/node_modules/react-router-dom/server.mjs"],"sourcesContent":["import * as React from 'react';\nimport { Action, invariant, isRouteErrorResponse, UNSAFE_convertRoutesToDataRoutes, IDLE_NAVIGATION, IDLE_FETCHER } from '@remix-run/router';\nimport { parsePath, Router, UNSAFE_DataStaticRouterContext, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, Routes, UNSAFE_enhanceManualRouteObjects, createPath } from 'react-router-dom';\n\n/**\n * A <Router> that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouter({\n  basename,\n  children,\n  location: locationProp = \"/\"\n}) {\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let action = Action.Pop;\n  let location = {\n    pathname: locationProp.pathname || \"/\",\n    search: locationProp.search || \"\",\n    hash: locationProp.hash || \"\",\n    state: locationProp.state || null,\n    key: locationProp.key || \"default\"\n  };\n  let staticNavigator = getStatelessNavigator();\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: location,\n    navigationType: action,\n    navigator: staticNavigator,\n    static: true\n  });\n}\n\n/**\n * A Data Router that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouterProvider({\n  context,\n  router,\n  hydrate = true,\n  nonce\n}) {\n  !(router && context) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You must provide `router` and `context` to <StaticRouterProvider>\") : invariant(false) : void 0;\n  let dataRouterContext = {\n    router,\n    navigator: getStatelessNavigator(),\n    static: true,\n    basename: context.basename || \"/\"\n  };\n  let hydrateScript = \"\";\n\n  if (hydrate !== false) {\n    let data = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors)\n    }; // Use JSON.parse here instead of embedding a raw JS object here to speed\n    // up parsing on the client.  Dual-stringify is needed to ensure all quotes\n    // are properly escaped in the resulting string.  See:\n    //   https://v8.dev/blog/cost-of-javascript-2019#json\n\n    let json = JSON.stringify(JSON.stringify(data));\n    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n  }\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataStaticRouterContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {\n    value: dataRouterContext.router.state\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: dataRouterContext.basename,\n    location: dataRouterContext.router.state.location,\n    navigationType: dataRouterContext.router.state.historyAction,\n    navigator: dataRouterContext.navigator\n  }, /*#__PURE__*/React.createElement(Routes, null))))), hydrateScript ? /*#__PURE__*/React.createElement(\"script\", {\n    suppressHydrationWarning: true,\n    nonce: nonce,\n    dangerouslySetInnerHTML: {\n      __html: hydrateScript\n    }\n  }) : null);\n}\n\nfunction serializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // deserializeErrors in react-router-dom/index.tsx :)\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = { ...val,\n        __type: \"RouteErrorResponse\"\n      };\n    } else if (val instanceof Error) {\n      // Do not serialize stack traces from SSR for security reasons\n      serialized[key] = {\n        message: val.message,\n        __type: \"Error\"\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n\n  return serialized;\n}\n\nfunction getStatelessNavigator() {\n  return {\n    createHref,\n    encodeLocation,\n\n    push(to) {\n      throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n    },\n\n    replace(to) {\n      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere ` + `in your app.`);\n    },\n\n    go(delta) {\n      throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${delta})\\` somewhere in your app.`);\n    },\n\n    back() {\n      throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);\n    },\n\n    forward() {\n      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);\n    }\n\n  };\n} // Temporary manifest generation - we should optimize this by combining the\n// tree-walks between convertRoutesToDataRoutes, enhanceManualRouteObjects,\n// and generateManifest.\n// Also look into getting rid of `route as AgnosticDataRouteObject` down below?\n\n\nfunction generateManifest(routes, manifest = new Map()) {\n  routes.forEach(route => {\n    manifest.set(route.id, route);\n\n    if (route.children) {\n      generateManifest(route.children, manifest);\n    }\n  });\n  return manifest;\n}\n\nfunction createStaticRouter(routes, context) {\n  let dataRoutes = UNSAFE_convertRoutesToDataRoutes(UNSAFE_enhanceManualRouteObjects(routes));\n  let manifest = generateManifest(dataRoutes); // Because our context matches may be from a framework-agnostic set of\n  // routes passed to createStaticHandler(), we update them here with our\n  // newly created/enhanced data routes\n\n  let matches = context.matches.map(match => {\n    let route = manifest.get(match.route.id) || match.route;\n    return { ...match,\n      route: route\n    };\n  });\n\n  let msg = method => `You cannot use router.${method}() on the server because it is a stateless environment`;\n\n  return {\n    get basename() {\n      return context.basename;\n    },\n\n    get state() {\n      return {\n        historyAction: Action.Pop,\n        location: context.location,\n        matches,\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: context.errors,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        fetchers: new Map()\n      };\n    },\n\n    get routes() {\n      return dataRoutes;\n    },\n\n    initialize() {\n      throw msg(\"initialize\");\n    },\n\n    subscribe() {\n      throw msg(\"subscribe\");\n    },\n\n    enableScrollRestoration() {\n      throw msg(\"enableScrollRestoration\");\n    },\n\n    navigate() {\n      throw msg(\"navigate\");\n    },\n\n    fetch() {\n      throw msg(\"fetch\");\n    },\n\n    revalidate() {\n      throw msg(\"revalidate\");\n    },\n\n    createHref,\n    encodeLocation,\n\n    getFetcher() {\n      return IDLE_FETCHER;\n    },\n\n    deleteFetcher() {\n      throw msg(\"deleteFetcher\");\n    },\n\n    dispose() {\n      throw msg(\"dispose\");\n    },\n\n    _internalFetchControllers: new Map(),\n    _internalActiveDeferreds: new Map()\n  };\n}\n\nfunction createHref(to) {\n  return typeof to === \"string\" ? to : createPath(to);\n}\n\nfunction encodeLocation(to) {\n  // Locations should already be encoded on the server, so just return as-is\n  let path = typeof to === \"string\" ? parsePath(to) : to;\n  return {\n    pathname: path.pathname || \"\",\n    search: path.search || \"\",\n    hash: path.hash || \"\"\n  };\n}\n\nexport { StaticRouter, StaticRouterProvider, createStaticRouter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}